#pragma config(Sensor, S1,     TrayResetButton, sensorTouch)
#pragma config(Sensor, S3,     ColorScanner,   sensorColorNxtFULL)
#pragma config(Motor,  motorB,          TrayMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          SorterMotor,   tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void ResetTray(int power)
{
	while(SensorValue[TrayResetButton] == 0)
	{
		motor[TrayMotor] = power;
	}
	motor[TrayMotor] = 0;
}


void MoveTrayByDegrees(int power, int targetDegree)
{
	nMotorEncoder[TrayMotor] = 0;
	while(abs(nMotorEncoder[TrayMotor]) < targetDegree)
	{
		motor[TrayMotor] = power;
	}
	motor[TrayMotor] = 0;
}

bool isDegreesForSorterReached(int target, int direction)
{
	int degreesMoved = abs(nMotorEncoder[SorterMotor]);
	displayTextLine(1,"Target: %i", target);
	if(degreesMoved < target)
	{
		return true;
	}
	else if(degreesMoved > target && direction < 0)
	{
		return true;
	}
	return false;
}

void MoveSorterByDegrees(int power, int targetDegree)
{
	nMotorEncoder[SorterMotor] = 0;
	while(isDegreesForSorterReached(targetDegree, sgn(power)))
	{
		motor[SorterMotor] = power;
	}
	motor[SorterMotor] = 0;
}

void MoveToSortingPosition(int positionToMoveTo, int currentPosition, int power = 13,	int tolerance = 0)
{
	bool isOnLastMovingToFirst = positionToMoveTo == 0 && currentPosition == 270;
	bool isOnFirstMovingToLast = positionToMoveTo == 270 && currentPosition == 0;
	if(isOnLastMovingToFirst)
	{
		positionToMoveTo = 360;
	}
	else if(isOnFirstMovingToLast)
	{
		currentPosition = 360;
	}
	int distanceToMove = positionToMoveTo - currentPosition;
	int direction = sgn(distanceToMove);

	power *= direction;
	displayTextLine(0,"Power: %i", power);
	MoveSorterByDegrees(power, abs(distanceToMove) + tolerance);
}

void SortGumballs(int numberOfGumballs, int ballTravelTime, int sorterPower, int tolerance = 0)
{
	const int numberOfColors = 6;
	int ballsSorted = 0;
	bool wasPositionDecided[numberOfColors];
	int positionToDrop[numberOfColors];

	int positionTracker = -1;
	int previousPosition = positionTracker;

	for(int i = 0; i < numberOfColors; i++)
	{
		positionToDrop[i] = positionTracker;
		wasPositionDecided[i] = false;
	}

	do
	{
		ResetTray(50);
		//Move tray to scanning position
		MoveTrayByDegrees(100, 270);
		//delay to allow balls to settle
		delay(ballTravelTime);

		TColors ScannedColor = (TColors)SensorValue[ColorScanner];
		switch(ScannedColor)
		{
			case REDCOLOR:
				displayTextLine(6,"RED");
				if(!wasPositionDecided[REDCOLOR])
				{

					positionTracker++;
					positionToDrop[REDCOLOR] = positionTracker * 90;
					delay(10);
					wasPositionDecided[REDCOLOR] = true;
				}
				MoveToSortingPosition(positionToDrop[REDCOLOR], previousPosition, sorterPower);

				previousPosition = positionToDrop[REDCOLOR];
				ballsSorted++;
				break;

			case GREENCOLOR:
				displayTextLine(6,"GREEN");
				if(!wasPositionDecided[GREENCOLOR])
				{
					positionTracker++;
					positionToDrop[GREENCOLOR] = positionTracker * 90;
					delay(10);
					wasPositionDecided[GREENCOLOR] = true;
				}
				MoveToSortingPosition(positionToDrop[GREENCOLOR], previousPosition, sorterPower);

				previousPosition = positionToDrop[GREENCOLOR];
				ballsSorted++;
				break;

			case BLUECOLOR:
				displayTextLine(6,"BLUE");
				if(!wasPositionDecided[BLUECOLOR])
				{
					positionTracker++;
					positionToDrop[BLUECOLOR] = positionTracker * 90;
					delay(10);
					wasPositionDecided[BLUECOLOR] = true;
				}
				MoveToSortingPosition(positionToDrop[BLUECOLOR], previousPosition, sorterPower);

				previousPosition = positionToDrop[BLUECOLOR];
				ballsSorted++;
				break;

			case YELLOWCOLOR:
				displayTextLine(6,"YELLOW");
				if(!wasPositionDecided[YELLOWCOLOR])
				{
					positionTracker++;
					positionToDrop[YELLOWCOLOR] = positionTracker * 90;
					delay(10);
					wasPositionDecided[YELLOWCOLOR] = true;
				}
				MoveToSortingPosition(positionToDrop[YELLOWCOLOR], previousPosition, sorterPower);

				previousPosition = positionToDrop[YELLOWCOLOR];
				ballsSorted++;
				break;

			default:
				playSound(soundBeepBeep);

		}
		displayTextLine(6,"Balls Sorted: %i", ballsSorted);
	}while(ballsSorted < numberOfGumballs);
	ResetTray(100);
}


task main()
{
	SortGumballs(12, 1300, 10);
}
